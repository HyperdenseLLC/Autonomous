<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Shrinking Overworld (Zero-Player)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root { color-scheme: dark; }
  * { box-sizing: border-box; }
  body {
    margin: 0; background:#0d0f14; color:#d8d8d8;
    font-family: ui-monospace, SFMono-Regular, Menlo, "Fira Mono","Source Code Pro", monospace;
    display:flex; flex-direction:column; min-height:100vh;
  }
  header {
    display:flex; flex-wrap:wrap; gap:.5rem; align-items:center;
    padding:.5rem 1rem; background:#11131a; border-bottom:1px solid #20222c;
  }
  header input[type="text"]{ background:#1b1e27; border:1px solid #2c3140; color:inherit; padding:.3rem .5rem; min-width:12rem;}
  header button{ background:#262b3a; border:1px solid #3a4257; color:inherit; padding:.35rem .7rem; cursor:pointer; font:inherit; }
  header button.active{ background:#3a4260; border-color:#566189; }
  header button:disabled{ opacity:.45; cursor:not-allowed; }
  main { flex:1; display:flex; min-height:0; }
  #viewport { flex:1; display:flex; justify-content:center; align-items:center; background:#0f1118; position:relative; }
  canvas { image-rendering: pixelated; background:#000; border:1px solid #1b1f2a; box-shadow:0 0 .75rem rgba(0,0,0,.4);}
  aside { width:300px; max-width:100vw; border-left:1px solid #20222c; background:#141621; display:flex; flex-direction:column; }
  #stats { padding:.75rem 1rem; border-bottom:1px solid #1e202b; font-size:.85rem; line-height:1.5; }
  #entropy-bar { width:100%; height:.75rem; background:#20222c; border:1px solid #3a3e52; margin-top:.4rem; position:relative;}
  #entropy-bar span { display:block; height:100%; background:linear-gradient(90deg, #3aa35c, #c97e2e, #d94444); }
  #log { flex:1; padding:.75rem 1rem; overflow-y:auto; font-size:.8rem; }
  #log p { margin:0 0 .35rem; white-space:pre-wrap; }
  footer { text-align:center; padding:.5rem 0; font-size:.72rem; opacity:.55; }
  /* Error overlay */
  #err {
    position:fixed; left:0; right:0; bottom:0; background:#2b1a1a; color:#ffd6d6;
    padding:.5rem .75rem; font-size:.8rem; border-top:1px solid #4a2a2a; display:none; white-space:pre-wrap;
  }
</style>
</head>
<body>
<header>
  <label for="seed" style="opacity:.75;font-size:.85rem;">Seed</label>
  <input id="seed" type="text" placeholder="world-seed" />
  <button id="new-seed">New Seed</button>
  <button id="play-pause">Pause</button>
  <div>
    <button data-speed="1" class="active">×1</button>
    <button data-speed="2">×2</button>
    <button data-speed="4">×4</button>
  </div>
  <button id="save">Save</button>
  <button id="load">Load</button>
  <span id="status" style="margin-left:auto;font-size:0.75rem;opacity:0.65;"></span>
</header>
<main>
  <section id="viewport">
    <canvas id="game" width="320" height="180"></canvas>
  </section>
  <aside>
    <div id="stats">
      <div><strong>Hero</strong></div>
      <div>HP: <span id="stat-hp">--</span></div>
      <div>Stamina: <span id="stat-stamina">--</span></div>
      <div>Hunger: <span id="stat-hunger">--</span></div>
      <div>Mood: <span id="stat-mood">--</span></div>
      <div>Cleared Shrines: <span id="stat-shrines">0</span></div>
      <div>Entropy: <span id="stat-entropy">0%</span></div>
      <div>Day Time: <span id="stat-daytime">--</span></div>
      <div id="entropy-bar"><span style="width:0%"></span></div>
    </div>
    <div id="log"></div>
  </aside>
</main>
<footer> Shrinking Overworld (Zero-Player) — autonomous simulation. Pause, seed, speed, save, load. </footer>
<div id="err"></div>

<script>
/* ---- Guarded run: any thrown error shows on-screen and console ---- */
(function guarded(){
  const showErr = (e) => {
    console.error(e);
    const el = document.getElementById('err');
    if (!el) return;
    el.style.display = 'block';
    el.textContent = (e && e.stack) ? e.stack : String(e);
  };
  try { main(); } catch(e){ showErr(e); }
  window.addEventListener('error', ev => showErr(ev.error || ev.message));
  window.addEventListener('unhandledrejection', ev => showErr(ev.reason || ev));
})();

/* ======================= GAME ======================= */
function main(){
  // --------- UTIL ---------
  const Util = {
    clamp:(v,min,max)=>Math.max(min,Math.min(max,v)),
    lerp:(a,b,t)=>a+(b-a)*t,
    choice:(arr,rng)=>arr[Math.floor(rng.next()*arr.length)],
    shuffle(array,rng){ for(let i=array.length-1;i>0;i--){ const j=Math.floor(rng.next()*(i+1)); [array[i],array[j]]=[array[j],array[i]]; } return array; },
    hexToRgb(hex){ const p=hex.replace('#',''); const n=parseInt(p,16); return {r:(n>>16)&255,g:(n>>8)&255,b:n&255}; },
    rgbToHex({r,g,b}){ const h=v=>Util.clamp(Math.round(v),0,255).toString(16).padStart(2,'0'); return `#${h(r)}${h(g)}${h(b)}`; },
    supportsLocalStorage(){ try{ const k='__t__'; localStorage.setItem(k,'1'); localStorage.removeItem(k); return true; }catch{return false;} }
  };

  // --------- RNG ---------
  const RNG = (()=> {
    function xmur3(str){ let h=1779033703 ^ str.length; for(let i=0;i<str.length;i++){ h=Math.imul(h ^ str.charCodeAt(i),3432918353); h=(h<<13)|(h>>>19);} return function(){ h=Math.imul(h ^ (h>>>16),2246822507); h=Math.imul(h ^ (h>>>13),3266489909); h^=h>>>16; return h>>>0; }; }
    function create(seedStr){ const seed=xmur3(seedStr); const s={a:seed(),b:seed(),c:seed(),d:seed()}; return gen(s); }
    function fromState(s){ return gen({...s}); }
    function gen(state){
      return {
        state,
        next(){
          // sfc32
          state.a >>>= 0; state.b >>>= 0; state.c >>>= 0; state.d >>>= 0;
          let t = (state.a + state.b) | 0;
          state.a = state.b ^ (state.b >>> 9);
          state.b = (state.c + (state.c << 3)) | 0;
          state.c = (state.c << 21) | (state.c >>> 11);
          state.d = (state.d + 1) | 0;
          t = (t + state.d) | 0;
          state.c = (state.c + t) | 0;
          return (t >>> 0) / 4294967296;
        },
        serialize(){ return {...state}; }
      };
    }
    return { create, fromState };
  })();

  // --------- NOISE ---------
  const Noise = (()=> {
    function valueNoise(x,y,o){
      const s = Math.sin((x*127.1 + y*311.7 + o) * 43758.5453);
      return s - Math.floor(s);
    }
    function fbm(x,y,o,oct=4){
      let v=0,a=0.5,f=1;
      for(let i=0;i<oct;i++){ v += a*valueNoise(x*f, y*f, o+i*17.17); a*=0.5; f*=2; }
      return v;
    }
    return { fbm };
  })();

  // --------- CONSTS ---------
  const TILE = { WATER:'water', FOREST:'forest', WILTED:'wilted', WASTE:'wasteland', MOUNTAIN:'mountain', PLAIN:'plain', TOWN:'town', SHRINE:'shrine', RUIN:'ruin' };
  const COLOR = {
    [TILE.WATER]: rgb('#2d4da8'), [TILE.FOREST]: rgb('#2f8f4b'), [TILE.WILTED]: rgb('#5c7142'),
    [TILE.WASTE]: rgb('#6b4a3a'), [TILE.MOUNTAIN]: rgb('#8a8f9f'), [TILE.PLAIN]: rgb('#9ec45a'),
    [TILE.TOWN]: rgb('#d9b46b'), [TILE.SHRINE]: rgb('#c27bd1'), [TILE.RUIN]: rgb('#8a6f4b')
  };
  function rgb(h){ return Util.hexToRgb(h); }

  const TILE_SIZE = 5;
  const MAP_W = 64, MAP_H = 36;              // 64*5=320, 36*5=180 -> matches canvas
  const DAY_LEN = 1200;

  // --------- MAP GEN ---------
  const MapGen = (()=> {
    function generate(seed,rng){
      const tiles = new Array(MAP_W*MAP_H);
      const pass = [];
      const offA = rng.next()*1000;
      const offB = rng.next()*2000 + 2000;

      for(let y=0;y<MAP_H;y++){
        for(let x=0;x<MAP_W;x++){
          const idx = x + y*MAP_W;
          const nx = x/MAP_W - .5, ny = y/MAP_H - .5;
          const h = Noise.fbm(nx*3, ny*3, offA, 4);
          const m = Noise.fbm(nx*4+50, ny*4+50, offB, 3);
          let type;
          if (h < 0.32) type = TILE.WATER;
          else if (h > 0.78) type = TILE.MOUNTAIN;
          else type = (m > 0.58) ? TILE.FOREST : (m < 0.28) ? TILE.PLAIN : (rng.next()<.5?TILE.FOREST:TILE.PLAIN);
          tiles[idx] = { type, explored:false };
          if (type!==TILE.WATER && type!==TILE.MOUNTAIN) pass.push({x,y});
        }
      }

      const towns = place(rng, pass, tiles, TILE.TOWN, pick([3,4,5]));
      const shrines = place(rng, pass, tiles, TILE.SHRINE, pick([4,5,6]));
      const ruins = place(rng, pass, tiles, TILE.RUIN, pick([3,4,5]));

      return { seed, tiles, towns, shrines, ruins, width:MAP_W, height:MAP_H,
        entropy:0, entropyStage:0, exploredTiles:0, time:0, paletteShift:0 };
      function pick(arr){ return Util.choice(arr, rng); }
    }
    function place(rng, pool, tiles, type, count){
      const out = [];
      const cands = pool.slice();
      Util.shuffle(cands, rng);
      for(let i=0;i<count && cands.length;i++){
        const s = cands.shift(); const idx = s.x + s.y*MAP_W;
        tiles[idx] = { type, explored:false };
        out.push({ x:s.x, y:s.y, cleared:false });
        const k = pool.findIndex(p=>p.x===s.x && p.y===s.y); if (k>=0) pool.splice(k,1);
      }
      return out;
    }
    return { generate };
  })();

  // --------- PATHFINDING ---------
  const Path = (()=> {
    function passable(t){ return t!==TILE.WATER && t!==TILE.MOUNTAIN; }
    function h(a,b){ return Math.abs(a.x-b.x)+Math.abs(a.y-b.y); }
    function neigh(x,y){ return [{x:x+1,y},{x:x-1,y},{x,y:y+1},{x,y:y-1}]; }
    function key(p){ return p.x+','+p.y; }

    function find(world, start, goal, maxNodes=8000){
      if (start.x===goal.x && start.y===goal.y) return [start];
      const open = [{pos:start, f:h(start,goal)}];
      const came = new Map(), g = new Map([[key(start),0]]), f = new Map([[key(start),h(start,goal)]]);
      const closed = new Set();
      let visited=0;

      while(open.length){
        if (++visited > maxNodes) return null; // bailout prevents freezes
        open.sort((a,b)=>a.f-b.f);
        const cur = open.shift(); const ck = key(cur.pos);
        if (cur.pos.x===goal.x && cur.pos.y===goal.y) return rebuild(came, cur.pos);
        closed.add(ck);
        for(const n of neigh(cur.pos.x, cur.pos.y)){
          if(n.x<0||n.y<0||n.x>=world.width||n.y>=world.height) continue;
          const tile = world.tiles[n.x + n.y*world.width];
          if(!passable(tile.type)) continue;
          const nk = key(n); if (closed.has(nk)) continue;
          const tentative = (g.get(ck) ?? Infinity) + 1;
          if(tentative < (g.get(nk) ?? Infinity)){
            came.set(nk, cur.pos); g.set(nk, tentative);
            const nf = tentative + h(n,goal); f.set(nk, nf);
            const exist = open.find(o=>o.pos.x===n.x && o.pos.y===n.y);
            if (exist) exist.f = nf; else open.push({pos:{x:n.x,y:n.y}, f:nf});
          }
        }
      }
      return null;
    }
    function rebuild(came, cur){
      const path=[cur]; let k=key(cur);
      while(came.has(k)){ cur=came.get(k); k=key(cur); path.unshift(cur); }
      return path;
    }
    return { find, passable };
  })();

  // --------- ENTROPY ---------
  const Entropy = (()=> {
    function increase(world, amt, rng, log){
      const prev = world.entropy;
      world.entropy = Util.clamp(world.entropy + amt, 0, 100);
      if (Math.floor(prev/20) !== Math.floor(world.entropy/20)) threshold(world, rng, log);
    }
    function threshold(world, rng, log){
      const lvl = Math.floor(world.entropy/20);
      world.entropyStage = lvl;
      // mutate
      const idxs = { forest:[], wilted:[], plain:[] };
      for(let i=0;i<world.tiles.length;i++){
        const t = world.tiles[i].type;
        if (t===TILE.FOREST) idxs.forest.push(i);
        if (t===TILE.WILTED) idxs.wilted.push(i);
        if (t===TILE.PLAIN) idxs.plain.push(i);
      }
      const conv = Math.max(5, Math.floor(world.tiles.length*0.04));
      mutate(idxs.forest, TILE.WILTED, (lvl>=1)?conv:0);
      mutate(idxs.wilted, TILE.WASTE,  (lvl>=2)?conv:0);
      mutate(idxs.plain,  TILE.WILTED, (lvl>=3)?Math.floor(conv/2):0);
      mutate(idxs.forest.concat(idxs.plain), TILE.WASTE, (lvl>=4)?Math.floor(conv/2):0);
      world.paletteShift = Math.min(.6, lvl*0.12);
      log(`Entropy surges to level ${lvl}. The world trembles.`);
      function mutate(arr, to, count){
        for(let i=0;i<count && arr.length;i++){
          const j = Math.floor(rng.next()*arr.length);
          world.tiles[arr[j]].type = to;
        }
      }
    }
    return { increase };
  })();

  // --------- HERO AI ---------
  const Hero = (()=> {
    function create(world){
      const home = world.towns[0] || {x: (world.width>>1), y:(world.height>>1)};
      return { x:home.x, y:home.y, displayX:home.x, displayY:home.y,
        hp:.9, stamina:.9, hunger:.7, mood:.8,
        moveProgress:0, moveSpeed:.22, path:[{x:home.x,y:home.y}], goal:null, restTimer:0,
        visitedShrines:{}, shrinesCleared:0, lastTile:`${home.x},${home.y}` };
    }
    function update(h, world, rng, log){
      if (h.restTimer>0){ h.restTimer--; recover(h,world); if(h.restTimer===0) log('Hero finishes resting at town.'); }
      else degrade(h,world);

      const idx = h.x + h.y*world.width;
      const tile = world.tiles[idx];
      if (tile && !tile.explored){ tile.explored=true; world.exploredTiles++; Entropy.increase(world, .03, rng, log); }

      if (h.path.length<=1) chooseGoal(h,world,rng,log);
      if (h.restTimer>0) return;

      move(h, world, log, rng);
      h.displayX = Util.lerp(h.displayX, h.x, .5);
      h.displayY = Util.lerp(h.displayY, h.y, .5);
    }
    function degrade(h, world){
      const fatigue = .002 + world.entropy*.00003;
      h.stamina = Util.clamp(h.stamina - fatigue, 0, 1);
      h.hunger  = Util.clamp(h.hunger  - .0015, 0, 1);
      if (h.hunger < .25){ h.hp = Util.clamp(h.hp - .002, 0, 1); h.mood = Util.clamp(h.mood - .001, 0, 1); }
    }
    function recover(h, world){
      const r = .02 * (1 - world.entropy*.004);
      h.stamina = Util.clamp(h.stamina + r, 0, 1);
      h.hp      = Util.clamp(h.hp + r*.8, 0, 1);
      h.hunger  = Util.clamp(h.hunger + r*.4, 0, 1);
      h.mood    = Util.clamp(h.mood + r*.5, 0, 1);
    }
    function chooseGoal(h, world, rng, log){
      const needRest = (h.stamina<.35 || h.hp<.4);
      if (needRest){
        const t = nearest(h, world.towns);
        if (t){
          if (h.x===t.x && h.y===t.y){ if(h.restTimer===0){ h.restTimer=60; log('Hero settles in town to recover.'); } h.goal=null; h.path=[{x:h.x,y:h.y}]; return; }
          h.goal = {...t, type:'town'}; compute(h,world,h.goal,log); return;
        }
      }
      const s = nearest(h, world.shrines.filter(s=>!s.cleared));
      if (s){ h.goal = {...s, type:'shrine'}; compute(h,world,h.goal,log); return; }
      const w = wanderTarget(world, rng);
      h.goal = {...w, type:'wander'}; compute(h,world,h.goal,log);
    }
    function compute(h, world, goal, log){
      const p = Path.find(world, {x:h.x,y:h.y}, {x:goal.x,y:goal.y});
      if (!p || p.length===0){ h.path=[{x:h.x,y:h.y}]; log('Hero is lost. Pathfinding failed. Wandering.'); h.goal=null; return; }
      h.path = p; h.moveProgress=0;
      if (goal.type==='shrine') log(`Hero plots a course to shrine at (${goal.x}, ${goal.y}).`);
      else if (goal.type==='town') log(`Hero seeks rest at town (${goal.x}, ${goal.y}).`);
    }
    function move(h, world, log, rng){
      if (h.path.length<=1) return;
      const [cur,next] = [h.path[0], h.path[1]];
      h.moveProgress += h.moveSpeed;
      if (h.moveProgress>=1){
        h.moveProgress=0; h.path.shift();
        h.x = next.x|0; h.y = next.y|0;
        arrive(h, world.tiles[h.x + h.y*world.width], world, log, rng);
      }
    }
    function arrive(h, tile, world, log, rng){
      const k = `${h.x},${h.y}`;
      if (k!==h.lastTile){ h.lastTile=k; if (typeof window.onEnterTile==='function') window.onEnterTile(h, tile); }
      if (!tile) return;
      if (tile.type===TILE.TOWN){ if (h.stamina<.8 || h.hp<.8){ h.restTimer=60; log('Hero begins resting at a town.'); } }
      else if (tile.type===TILE.SHRINE){ clearShrine(h,world,log,rng); }
      else if (tile.type===TILE.RUIN){ h.mood=Util.clamp(h.mood-.02,0,1); log('Hero wanders through old ruins, feeling uneasy.'); }
    }
    function clearShrine(h, world, log, rng){
      const s = world.shrines.find(s=>s.x===h.x && s.y===h.y);
      if (s && !s.cleared){
        s.cleared=true; h.visitedShrines[`${s.x},${s.y}`]=true; h.shrinesCleared++;
        h.mood=Util.clamp(h.mood+.1,0,1); Entropy.increase(world, 5, rng, log);
        log(`Hero clears a shrine at (${s.x}, ${s.y}). Entropy swells.`);
        if (typeof window.onShrineCleared==='function') window.onShrineCleared(s);
      }
    }
    function nearest(h, pts){ if(!pts||!pts.length) return null; let b=null, d=1e9; for(const p of pts){ const dd=Math.abs(p.x-h.x)+Math.abs(p.y-h.y); if(dd<d){d=dd;b=p;} } return b; }
    function wanderTarget(world, rng){
      const opts = [...world.towns, ...world.shrines, ...world.ruins];
      // sample a few plains/forests to keep list small
      for(let i=0;i<200;i++){
        const x=(rng.next()*world.width)|0, y=(rng.next()*world.height)|0;
        const t = world.tiles[x + y*world.width].type;
        if (t===TILE.PLAIN || t===TILE.FOREST) opts.push({x,y});
      }
      return opts.length?Util.choice(opts, rng):{x:(world.width>>1), y:(world.height>>1)};
    }
    return { create, update };
  })();

  // --------- RENDER ---------
  const Render = (()=> {
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    if (!ctx) throw new Error('Canvas 2D context unavailable.');
    ctx.imageSmoothingEnabled = false;

    function syncCanvasToMap(){
      const w = MAP_W*TILE_SIZE, h = MAP_H*TILE_SIZE;
      if (canvas.width!==w || canvas.height!==h){ canvas.width=w; canvas.height=h; }
      resize();
    }
    function resize(){
      const parent = canvas.parentElement;
      const maxW = parent.clientWidth|0, maxH = parent.clientHeight|0;
      const scale = Math.max(1, Math.floor(Math.min(maxW / canvas.width, maxH / canvas.height)));
      canvas.style.width  = (canvas.width * scale) + 'px';
      canvas.style.height = (canvas.height * scale) + 'px';
    }
    window.addEventListener('resize', resize);

    function draw(world, hero){
      if (!world || !hero) return;
      const bright = dayBrightness(world.time);
      const tint = world.paletteShift;
      // tiles
      for(let y=0;y<world.height;y++){
        for(let x=0;x<world.width;x++){
          const t = world.tiles[x + y*world.width].type;
          ctx.fillStyle = tileColor(t, bright, tint);
          ctx.fillRect(x*TILE_SIZE|0, y*TILE_SIZE|0, TILE_SIZE, TILE_SIZE);
        }
      }
      // hero
      const px = (hero.displayX*TILE_SIZE + (TILE_SIZE>>1))|0;
      const py = (hero.displayY*TILE_SIZE + (TILE_SIZE>>1))|0;
      const frame = ((world.time/10)|0)%2;
      ctx.fillStyle = frame? '#f7d97a':'#ffe680';
      ctx.fillRect(px-1, py-2, 3, 3);
      ctx.fillStyle = frame? '#c94f4f':'#d95f5f';
      ctx.fillRect(px-1, py-1, 3, 1);
      overlays(world);
    }
    function dayBrightness(t){
      const v = (t % DAY_LEN) / DAY_LEN;
      const cyc = Math.sin((v*Math.PI*2) - Math.PI/2)*.5 + .5;
      return .4 + cyc*.6;
    }
    function tileColor(type, bright, tint){
      const base = COLOR[type] || COLOR[TILE.PLAIN];
      const mix = { r: base.r + (120-base.r)*tint, g: base.g + (110-base.g)*tint, b: base.b + (120-base.b)*tint };
      return Util.rgbToHex({ r: mix.r*bright, g: mix.g*bright, b: mix.b*bright });
    }
    function overlays(world){
      const e = world.entropy/100;
      if (e>0){ ctx.fillStyle = `rgba(120,40,40, ${e*0.25})`; ctx.fillRect(0,0,canvas.width,canvas.height); }
      const v = (world.time % DAY_LEN) / DAY_LEN;
      const night = Math.cos(v*Math.PI*2)*.5 + .5;
      ctx.fillStyle = `rgba(10,14,30, ${night*.35})`; ctx.fillRect(0,0,canvas.width,canvas.height);
    }
    syncCanvasToMap();
    return { draw, resize, syncCanvasToMap };
  })();

  // --------- UI & PERSIST ---------
  const UI = (()=>{
    const seedEl = document.getElementById('seed');
    const newSeedBtn = document.getElementById('new-seed');
    const playBtn = document.getElementById('play-pause');
    const speedBtns = [...document.querySelectorAll('[data-speed]')];
    const entropyBar = document.querySelector('#entropy-bar span');
    const status = document.getElementById('status');
    const saveBtn = document.getElementById('save'), loadBtn = document.getElementById('load');
    const stats = {
      hp: byId('stat-hp'), stamina: byId('stat-stamina'), hunger: byId('stat-hunger'),
      mood: byId('stat-mood'), shrines: byId('stat-shrines'), entropy: byId('stat-entropy'),
      daytime: byId('stat-daytime')
    };
    const logPanel = document.getElementById('log');
    let logs = [];

    function byId(id){ return document.getElementById(id); }
    function setSeed(v){ seedEl.value = v; }
    function setStatus(t){ status.textContent = t||''; }
    function log(msg){
      const ts = `T${Game.world?Game.world.time:0}`;
      logs.push(`${ts} — ${msg}`); if (logs.length>50) logs = logs.slice(-50);
      renderLog();
    }
    function renderLog(){
      logPanel.innerHTML = '';
      for(const line of logs){ const p=document.createElement('p'); p.textContent=line; logPanel.appendChild(p); }
      logPanel.scrollTop = logPanel.scrollHeight;
    }
    function resetLog(){ logs=[]; renderLog(); }
    function updateStats(hero, world){
      if(!hero||!world) return;
      stats.hp.textContent = pct(hero.hp);
      stats.stamina.textContent = pct(hero.stamina);
      stats.hunger.textContent = pct(hero.hunger);
      stats.mood.textContent = pct(hero.mood);
      stats.shrines.textContent = hero.shrinesCleared;
      stats.entropy.textContent = world.entropy.toFixed(1)+'%';
      entropyBar.style.width = world.entropy+'%';
      const day = Math.floor(world.time/DAY_LEN)+1;
      const hour = Math.floor(((world.time%DAY_LEN)/DAY_LEN)*24);
      stats.daytime.textContent = `Day ${day}, ${String(hour).padStart(2,'0')}:00`;
    }
    function pct(v){ return Math.round(Util.clamp(v,0,1)*100)+'%'; }

    // Bindings
    newSeedBtn.addEventListener('click', ()=>{
      const s = seedEl.value.trim() || `seed-${Math.floor(Math.random()*1e9)}`;
      Game.init(s);
    });
    playBtn.addEventListener('click', ()=>{
      GameLoop.togglePause(); playBtn.textContent = GameLoop.paused? 'Play':'Pause';
    });
    speedBtns.forEach(btn=>{
      btn.addEventListener('click', ()=>{
        GameLoop.setSpeed(Number(btn.dataset.speed));
        speedBtns.forEach(b=>b.classList.toggle('active', b===btn));
      });
    });
    if(!Util.supportsLocalStorage()){ saveBtn.disabled=true; loadBtn.disabled=true; setStatus('localStorage unavailable'); }
    else {
      saveBtn.addEventListener('click', ()=>Persist.save());
      loadBtn.addEventListener('click', ()=>Persist.load());
    }

    return { setSeed, setStatus, resetLog, log, updateStats, playBtn };
  })();

  const Persist = (()=>{
    const KEY='shrinking-overworld-save-v1';
    function save(){
      if(!Game.world||!Game.hero) return;
      localStorage.setItem(KEY, JSON.stringify({
        version:1, seed:Game.seed, world:serWorld(Game.world), hero:Game.hero, rng:Game.rng.serialize()
      }));
      UI.setStatus('Saved');
    }
    function load(){
      const raw = localStorage.getItem(KEY);
      if(!raw) return UI.setStatus('No save found');
      try{
        const p = JSON.parse(raw);
        if (p.version!==1) return UI.setStatus('Save version mismatch');
        Game.restore(p);
        UI.setStatus('Loaded');
      }catch(e){ console.error(e); UI.setStatus('Failed to load'); }
    }
    function serWorld(w){
      return {
        ...w,
        tiles: w.tiles.map(t=>({type:t.type, explored:t.explored})),
        towns: w.towns.map(x=>({...x})),
        shrines: w.shrines.map(x=>({...x})),
        ruins: w.ruins.map(x=>({...x}))
      };
    }
    return { save, load };
  })();

  // --------- GAME STATE ---------
  const Game = {
    seed:'', rng:null, world:null, hero:null,
    init(seed){
      this.seed = seed;
      UI.setSeed(seed);
      UI.resetLog?.();
      location.hash = encodeURIComponent(seed);
      this.rng   = RNG.create(seed);
      this.world = MapGen.generate(seed, RNG.create(seed+'-map'));
      this.hero  = Hero.create(this.world);
      UI.log(`World born from seed "${seed}".`);
      UI.updateStats(this.hero, this.world);
      Render.syncCanvasToMap();
      Render.resize();
    },
    restore(payload){
      this.seed = payload.seed; UI.setSeed(payload.seed); UI.resetLog?.();
      location.hash = encodeURIComponent(payload.seed);
      this.rng = RNG.fromState(payload.rng);
      this.world = payload.world; this.hero = payload.hero;
      if (typeof this.hero.displayX!=='number'){ this.hero.displayX=this.hero.x; this.hero.displayY=this.hero.y; }
      UI.log(`Save from seed "${this.seed}" restored.`);
      UI.updateStats(this.hero, this.world);
      Render.syncCanvasToMap(); Render.resize();
    }
  };

  // --------- LOOP ---------
  const GameLoop = (()=>{
    const TPS = 12; let speed=1, paused=false; let last=performance.now(), acc=0;
    function setSpeed(s){ speed=s; }
    function togglePause(){ paused=!paused; return paused; }
    function loop(now){
      const dt = (now-last)/1000; last=now;
      if(!paused && Game.world){
        acc += dt*speed*TPS;
        while(acc>=1){ tick(); acc-=1; }
      }
      render(); requestAnimationFrame(loop);
    }
    function tick(){
      Game.world.time++;
      Hero.update(Game.hero, Game.world, Game.rng, UI.log);
      Entropy.increase(Game.world, .005, Game.rng, UI.log);
      UI.updateStats(Game.hero, Game.world);
      if (typeof window.onTick==='function') window.onTick(Game.world);
    }
    function render(){ Render.draw(Game.world, Game.hero); }
    requestAnimationFrame(loop);
    return { setSpeed, togglePause, get paused(){ return paused; } };
  })();

  // --------- BOOT ---------
  document.addEventListener('visibilitychange', ()=>{
    if (document.hidden && !GameLoop.paused){
      GameLoop.togglePause(); UI.playBtn.textContent='Play';
    }
  });

  // Start after DOM is settled and canvas is confirmed
  (function bootstrap(){
    const hashSeed = decodeURIComponent((location.hash||'').replace('#',''));
    const seed = hashSeed || `seed-${Math.floor(Math.random()*1e6)}`;
    Game.init(seed);
    UI.setStatus('Ready');
  })();
}
/* ===== Extension hooks (optional) =====
window.onTick = (world)=>{};
window.onEnterTile = (hero,tile)=>{};
window.onShrineCleared = (s)=>{};
window.applyEntropy = (world,level)=>{};
*/
</script>
</body>
</html>
